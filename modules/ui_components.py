"""
UI Components and Discord interaction handlers.
Centralizes Discord UI elements like buttons, modals, and embeds.
"""

import logging
import discord
from discord import ui
from typing import Optional
import time
import sys

from modules.utils import truncate, format_duration, THEME_COLOR, ERR_COLOR
from modules.metrics import metric_inc

logger = logging.getLogger("Monica.UIComponents")


def _get_runtime():
    """L·∫•y players v√† bot ƒëang ch·∫°y t·ª´ module th·ª±c thi.

    ∆Øu ti√™n __main__ (khi ch·∫°y `python bot.py`), sau ƒë√≥ m·ªõi ƒë·∫øn 'bot'.
    Tr√°nh t√¨nh tr·∫°ng import l·∫°i `bot` t·∫°o module song song khi·∫øn state b·ªã l·ªách.
    Tr·∫£ v·ªÅ (players_dict, bot_obj). N·∫øu kh√¥ng c√≥ th√¨ tr·∫£ v·ªÅ ({}, None).
    """
    try:
        mod = sys.modules.get('__main__') or sys.modules.get('bot')
        players = getattr(mod, 'players', {}) if mod else {}
        bot_obj = getattr(mod, 'bot', None) if mod else None
        return players, bot_obj
    except Exception:
        return {}, None


class MusicControls(ui.View):
    """Enhanced music control buttons v·ªõi x·ª≠ l√Ω tr·∫°ng th√°i theo ng·ªØ c·∫£nh."""
    
    def __init__(self, guild_id: int, *, timeout: float = 300):
        super().__init__(timeout=timeout)
        self.guild_id = guild_id
        # √Åp d·ª•ng tr·∫°ng th√°i n√∫t theo b·ªëi c·∫£nh ngay khi t·∫°o
        try:
            self._apply_state()
            # N·∫øu view ƒë√£ ƒë∆∞·ª£c g·∫Øn v√†o message s·∫µn (khi edit), re-apply sau 1 tick ƒë·ªÉ ch·∫Øc ch·∫Øn
            async def _reapply_later():
                try:
                    await discord.utils.sleep_until(discord.utils.utcnow())  # schedule next loop tick
                    self._apply_state()
                    if getattr(self, 'message', None):
                        try:
                            await self.message.edit(view=self)
                        except Exception:
                            pass
                except Exception:
                    pass
            try:
                import asyncio as _aio
                _aio.create_task(_reapply_later())
            except Exception:
                pass
        except Exception:
            # Kh√¥ng l√†m gi√°n ƒëo·∫°n n·∫øu Discord internals thay ƒë·ªïi
            logger.debug("MusicControls: apply_state failed on init", exc_info=True)

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        """Validate user permissions and voice state for interactions."""
        # Gia h·∫°n th·ªùi gian s·ªëng c·ªßa View khi c√≥ t∆∞∆°ng t√°c
        try:
            self.timeout = max((self.timeout or 0), 120)
            self.restart()
        except Exception:
            pass
        if not interaction.user.voice or not interaction.user.voice.channel:
            await interaction.response.send_message(
                "‚ùå B·∫°n c·∫ßn v√†o voice channel ƒë·ªÉ s·ª≠ d·ª•ng.", ephemeral=True
            )
            return False
        
        # Import here to avoid circular imports
        from modules.voice_manager import get_voice_client_cached
        vc = get_voice_client_cached(interaction.client, interaction.guild)
        
        if not vc or not vc.is_connected():
            await interaction.response.send_message(
                "‚ùå Bot ch∆∞a k·∫øt n·ªëi voice channel.", ephemeral=True
            )
            return False
        
        if interaction.user.voice.channel.id != vc.channel.id:
            await interaction.response.send_message(
                "‚ùå B·∫°n ph·∫£i ·ªü c√πng voice channel v·ªõi bot.", ephemeral=True
            )
            return False
        
        # Refresh player's activity to avoid idle disconnect during interaction
        try:
            players, _ = _get_runtime()
            player = players.get(interaction.guild.id)
            if player:
                player._last_active = time.time()
        except Exception:
            pass
        
        return True

    async def on_timeout(self) -> None:
        """Khi View h·∫øt h·∫°n, c·ªë g·∫Øng gi·ªØ UI kh√¥ng ch·∫øt n·∫øu c√≤n ƒëang ph√°t."""
        try:
            _players, _ = _get_runtime()
            player = _players.get(self.guild_id) if _players else None
            vc = getattr(player, 'vc', None)
            still_active = bool(vc and (getattr(vc, 'is_playing', lambda: False)() or getattr(vc, 'is_paused', lambda: False)()))
            if still_active and getattr(self, 'message', None):
                # T·∫°o View m·ªõi v·ªõi timeout m·ªõi v√† thay th·∫ø
                new_view = MusicControls(self.guild_id, timeout=300)
                try:
                    await self.message.edit(view=new_view)
                    # G·∫Øn message cho view m·ªõi ƒë·ªÉ v√≤ng ƒë·ªùi n·ªëi ti·∫øp
                    new_view.message = self.message
                except Exception:
                    pass
        except Exception:
            logger.debug("MusicControls.on_timeout: failed to recreate view", exc_info=True)

    def _apply_state(self) -> None:
        """B·∫≠t/t·∫Øt c√°c n√∫t d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa player/voice.

        - Disable Skip/Stop n·∫øu kh√¥ng ƒëang ph√°t.
        - Disable Reverse n·∫øu kh√¥ng c√≥ l·ªãch s·ª≠.
        - Disable Queue n·∫øu h√†ng ƒë·ª£i tr·ªëng.
        """
        try:
            # L·∫•y player/voice hi·ªán t·∫°i (best-effort)
            try:
                _players, _bot = _get_runtime()
                from modules.voice_manager import get_voice_client_cached as _get_vc
                g = getattr(_bot, 'get_guild', lambda _gid: None)(self.guild_id) if _bot else None
                player = _players.get(self.guild_id) if _players else None
                vc = _get_vc(_bot, g) if _bot and g else None
            except Exception:
                player = None
                vc = None

            # X√°c ƒë·ªãnh tr·∫°ng th√°i ph√°t theo 2 ngu·ªìn: VoiceClient v√† player.current ƒë·ªÉ tr√°nh tr·∫°ng th√°i tr·ªÖ
            vc_play = bool(vc and (getattr(vc, 'is_playing', lambda: False)() or getattr(vc, 'is_paused', lambda: False)()))
            # consider "playing" if we have a current track or voice is playing/paused
            pl_play = bool(player and getattr(player, 'current', None))
            is_playing = bool(vc_play or pl_play)
            # Tr√°nh false-negative: ∆∞u ti√™n qsize() n·∫øu c√≥
            try:
                has_queue = bool(player and getattr(player, 'queue', None) and player.queue.qsize() > 0)
            except Exception:
                has_queue = bool(getattr(player, 'queue', None) and not player.queue.empty())
            # history viewable if deque has at least 1 item
            try:
                has_history = bool(player and getattr(player, 'history', None) and len(player.history) > 0)
            except Exception:
                has_history = bool(player and getattr(player, 'history', None))

            # T√¨m c√°c n√∫t theo label ho·∫∑c emoji
            btn_skip = None; btn_stop = None; btn_rev = None; btn_queue = None
            for item in self.children:
                if isinstance(item, ui.Button):
                    if item.label == "B·ªè qua" or item.emoji == "‚è≠Ô∏è":
                        btn_skip = item
                    elif item.label == "D·ª´ng ph√°t" or item.emoji == "‚èπÔ∏è":
                        btn_stop = item
                    elif item.label == "Quay l·∫°i" or item.emoji == "‚Ü©Ô∏è":
                        btn_rev = item
                    elif item.label == "H√†ng ƒë·ª£i" or item.emoji == "üìú":
                        btn_queue = item

            # Skip: enable if something is playing and there is a next item
            if btn_skip:
                btn_skip.disabled = not (is_playing and has_queue)
            # Stop: enable if voice is playing or paused, or player claims current
            if btn_stop:
                btn_stop.disabled = not is_playing
            # Reverse: enable if we have any history
            if btn_rev:
                btn_rev.disabled = not has_history
            # Queue: enable if queue has items (even if not playing yet)
            if btn_queue:
                btn_queue.disabled = not has_queue
        except Exception:
            logger.debug("MusicControls: _apply_state error", exc_info=True)

    @ui.button(emoji="‚èØÔ∏è", label="T·∫°m d·ª´ng/Ti·∫øp t·ª•c", style=discord.ButtonStyle.primary, row=0)
    async def pause_resume(self, inter: discord.Interaction, button: ui.Button):
        """Toggle pause/resume playback."""
        from modules.voice_manager import get_voice_client_cached
        vc = get_voice_client_cached(inter.client, inter.guild)
        try:
            metric_inc("ui_click_pause_resume")
        except Exception:
            pass
        
        if vc.is_playing():
            vc.pause()
            await inter.response.send_message("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng", ephemeral=True)
        elif vc.is_paused():
            vc.resume()
            await inter.response.send_message("‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c", ephemeral=True)
        else:
            await inter.response.send_message("‚ùå Kh√¥ng c√≥ g√¨ ƒë·ªÉ pause/resume", ephemeral=True)

    @ui.button(emoji="‚è≠Ô∏è", label="B·ªè qua", style=discord.ButtonStyle.secondary, row=0)
    async def skip(self, inter: discord.Interaction, button: ui.Button):
        """Skip current track."""
        from modules.voice_manager import get_voice_client_cached
        players, _ = _get_runtime()
        try:
            metric_inc("ui_click_skip")
        except Exception:
            pass
        
        vc = get_voice_client_cached(inter.client, inter.guild)
        player = players.get(inter.guild.id)
        
        if not vc or not vc.is_connected() or (not vc.is_playing() and not vc.is_paused()):
            await inter.response.send_message("‚ùå Kh√¥ng c√≥ g√¨ ƒë·ªÉ skip", ephemeral=True)
            return
        
        if player and player.queue.empty():
            await inter.response.send_message("‚ùå H√†ng ƒë·ª£i tr·ªëng", ephemeral=True)
            return
        
        # Handle loop_one mode
        if player and getattr(player, 'loop_one', False):
            player._suppress_loop_requeue_once = True
        
        # D·ª´ng ƒë·ªÉ chuy·ªÉn sang b√†i k·∫ø ti·∫øp trong v√≤ng l·∫∑p player
        vc.stop()
        await inter.response.send_message("‚è≠Ô∏è ƒê√£ skip b√†i hi·ªán t·∫°i", ephemeral=True)

    @ui.button(emoji="‚èπÔ∏è", label="D·ª´ng ph√°t", style=discord.ButtonStyle.danger, row=0)
    async def stop(self, inter: discord.Interaction, button: ui.Button):
        """Stop playback and clear queue."""
        from modules.voice_manager import get_voice_client_cached
        players, _ = _get_runtime()
        try:
            metric_inc("ui_click_stop")
        except Exception:
            pass
        
        vc = get_voice_client_cached(inter.client, inter.guild)
        player = players.get(inter.guild.id)
        
        if vc:
            try:
                vc.stop()
            except Exception:
                pass
        if player:
            try:
                await player.clear_all()
            except Exception:
                pass
        
        await inter.response.send_message("‚èπÔ∏è ƒê√£ d·ª´ng ph√°t v√† x√≥a h√†ng ƒë·ª£i", ephemeral=True)

    @ui.button(emoji="üìú", label="H√†ng ƒë·ª£i", style=discord.ButtonStyle.secondary, row=1)
    async def show_queue(self, inter: discord.Interaction, button: ui.Button):
        """Display current queue."""
        players, _ = _get_runtime()
        try:
            metric_inc("ui_click_queue")
        except Exception:
            pass
        
        player = players.get(inter.guild.id)
        if not player or player.queue.empty():
            await inter.response.send_message("üìú H√†ng ƒë·ª£i tr·ªëng", ephemeral=True)
            return
        
        upcoming = player.queue.snapshot()[:10]
        text = "\n".join(
            f"{idx+1}. {truncate(item.get('title') if isinstance(item, dict) else str(item), 45)} ‚Äî {format_duration(item.get('duration') if isinstance(item, dict) else None)}"
            for idx, item in enumerate(upcoming)
        )
        
        embed = discord.Embed(
            title="üìú H√†ng ƒë·ª£i (10 b√†i ti·∫øp theo)", 
            description=text, 
            color=THEME_COLOR
        )
        await inter.response.send_message(embed=embed, ephemeral=True)

    @ui.button(emoji="‚Ü©Ô∏è", label="Quay l·∫°i", style=discord.ButtonStyle.secondary, row=1)
    async def reverse(self, inter: discord.Interaction, button: ui.Button):
        """Play previous track."""
        players, _ = _get_runtime()
        try:
            metric_inc("ui_click_reverse")
        except Exception:
            pass
        
        player = players.get(inter.guild.id)
        if not player or not getattr(player, 'history', None):
            await inter.response.send_message("‚ùå Kh√¥ng c√≥ b√†i n√†o trong l·ªãch s·ª≠", ephemeral=True)
            return
        
        try:
            last = await player.play_previous_now()
            if last:
                title = truncate(last.get('title', 'Unknown'), 80)
                await inter.response.send_message(f"‚Ü©Ô∏è ƒêang chuy·ªÉn v·ªÅ: {title}", ephemeral=True)
            else:
                await inter.response.send_message("‚ùå Kh√¥ng th·ªÉ quay l·∫°i b√†i tr∆∞·ªõc", ephemeral=True)
        except Exception:
            await inter.response.send_message("‚ùå L·ªói khi quay l·∫°i b√†i tr∆∞·ªõc", ephemeral=True)


class ReportModal(ui.Modal, title="B√°o c√°o l·ªói g·∫∑p ph·∫£i"):
    """Enhanced bug report modal with better validation."""
    
    ten_loi = ui.TextInput(
        label="T√™n l·ªói b·∫°n g·∫∑p", 
        placeholder="VD: B·ªã gi·∫≠t, delay, kh√¥ng ph√°t ƒë∆∞·ª£c‚Ä¶", 
        required=True, 
        max_length=120
    )
    chuc_nang = ui.TextInput(
        label="Ch·ª©c nƒÉng li√™n quan ƒë·∫øn l·ªói", 
        placeholder="VD: play, skip, reverse, queue‚Ä¶", 
        required=True, 
        max_length=80
    )
    mo_ta = ui.TextInput(
        label="M√¥ t·∫£ chi ti·∫øt t√¨nh tr·∫°ng g·∫∑p l·ªói", 
        style=discord.TextStyle.paragraph, 
        required=True, 
        max_length=1500
    )

    def __init__(self, user: discord.abc.User, guild: Optional[discord.Guild]):
        super().__init__()
        self._user = user
        self._guild = guild

    async def on_submit(self, interaction: discord.Interaction):
        """Handle bug report submission with proper encoding."""
        try:
            report_content = (
                f"=== BUG REPORT [{time.strftime('%Y-%m-%d %H:%M:%S')}] ===\n"
                f"User: {self._user} (ID: {self._user.id})\n"
                f"Guild: {self._guild.name if self._guild else 'DM'} (ID: {self._guild.id if self._guild else 'N/A'})\n"
                f"Error: {self.ten_loi.value}\n"
                f"Function: {self.chuc_nang.value}\n"
                f"Description: {self.mo_ta.value}\n"
                "=" * 50 + "\n\n"
            )
            
            # Append to report_bug.log with UTF-8 encoding
            with open("report_bug.log", "a", encoding="utf-8") as f:
                f.write(report_content)
            
            logger.info("Bug report submitted by user %s", self._user.id)
            
        except Exception as e:
            logger.error("Failed to write bug report: %s", e)
        
        await interaction.response.send_message(
            "C·∫£m ∆°n b·∫°n ƒë√£ ƒë√≥ng g√≥p! B√°o c√°o ƒë√£ ƒë∆∞·ª£c ghi l·∫°i ‚ù§Ô∏è", 
            ephemeral=True
        )


# =============================
# Help UI (n√¢ng c·∫•p giao di·ªán tr·ª£ gi√∫p)
# =============================

def _fmt_cmd_list(lines: list[str]) -> str:
    """Gh√©p danh s√°ch l·ªánh th√†nh chu·ªói tho√°ng m√°t v√† d·ªÖ ƒë·ªçc."""
    return "\n\n".join(f"‚ñ∏ {line}" for line in lines)


def create_help_embed(page: str, *, prefix: str, version: str, stream_profile: str | None = None) -> discord.Embed:
    """T·∫°o embed tr·ª£ gi√∫p v·ªõi nhi·ªÅu trang (nh√≥m l·ªánh) ƒë·∫πp m·∫Øt v√† th√¢n thi·ªán.

    Args:
        page: T√™n trang hi·ªán t·∫°i (overview, playback, queue, loop, info, config, report, sources)
        prefix: Prefix cho l·ªánh text (VD: !)
        version: Phi√™n b·∫£n bot ƒë·ªÉ hi·ªÉn th·ªã footer
        stream_profile: Profile stream (stable/low-latency/super-low-latency)
    """
    page = (page or "overview").lower()

    footer = f"‚ú® Monica Music Bot {version}"
    if stream_profile:
        footer += f" ‚Ä¢ üéöÔ∏è {stream_profile.title()}"

    if page == "playback":
        embed = discord.Embed(
            title="üéµ Ph√°t nh·∫°c",
            description="ƒêi·ªÅu khi·ªÉn ph√°t nh·∫°c ƒë∆°n gi·∫£n v√† nhanh ch√≥ng",
            color=THEME_COLOR,
        )
        embed.add_field(
            name="üöÄ L·ªánh ch√≠nh",
            value=_fmt_cmd_list([
                "`/play <t√™n b√†i>` ‚Äî Ph√°t nh·∫°c",
                "`/pause` ‚Ä¢ `/resume` ‚Äî T·∫°m d·ª´ng/ti·∫øp t·ª•c", 
                "`/skip` ‚Ä¢ `/stop` ‚Äî B·ªè qua/d·ª´ng"
            ]),
            inline=False,
        )
        embed.add_field(
            name="üí° M·∫πo",
            value="Sau khi ph√°t nh·∫°c, d√πng **n√∫t b·∫•m** d∆∞·ªõi tin nh·∫Øn ƒë·ªÉ ƒëi·ªÅu khi·ªÉn nhanh h∆°n",
            inline=False,
        )
    elif page == "queue":
        embed = discord.Embed(
            title="üìú H√†ng ƒë·ª£i",
            description="Qu·∫£n l√Ω danh s√°ch ph√°t c·ªßa b·∫°n",
            color=THEME_COLOR,
        )
        embed.add_field(
            name="üéõÔ∏è L·ªánh ch√≠nh",
            value=_fmt_cmd_list([
                "`/queue` ‚Äî Xem danh s√°ch ph√°t",
                "`/clear <t√™n b√†i>` ‚Äî X√≥a b√†i theo t√™n",
                "`/clear_all` ‚Äî X√≥a t·∫•t c·∫£"
            ]),
            inline=False,
        )
    elif page == "loop":
        embed = discord.Embed(
            title="üîÅ Loop & L·ªãch s·ª≠",
            description="L·∫∑p l·∫°i nh·ªØng b√†i h√°t y√™u th√≠ch",
            color=THEME_COLOR,
        )
        embed.add_field(
            name="üéµ Ch·∫ø ƒë·ªô l·∫∑p",
            value=_fmt_cmd_list([
                "`/loop` ‚Äî L·∫∑p b√†i hi·ªán t·∫°i",
                "`/loop_all` ‚Äî L·∫∑p to√†n b·ªô danh s√°ch",
                "`/unloop` ‚Äî T·∫Øt ch·∫ø ƒë·ªô l·∫∑p"
            ]),
            inline=False,
        )
    elif page == "info":
        embed = discord.Embed(
            title="‚ÑπÔ∏è Th√¥ng tin & Gi√°m s√°t",
            description="Theo d√µi tr·∫°ng th√°i ho·∫°t ƒë·ªông c·ªßa Monica",
            color=THEME_COLOR,
        )
        embed.add_field(
            name="üîç L·ªánh th√¥ng tin",
            value=_fmt_cmd_list([
                "`/now` ‚Äî B√†i ƒëang ph√°t",
                "`/stats` ‚Äî Th·ªëng k√™ ho·∫°t ƒë·ªông",
                "`/health` ‚Äî Ki·ªÉm tra t√¨nh tr·∫°ng bot"
            ]),
            inline=False,
        )
    elif page == "config":
        embed = discord.Embed(
            title="‚öôÔ∏è C·∫•u h√¨nh & Debug",
            description="T√πy ch·ªânh Monica theo s·ªü th√≠ch c·ªßa b·∫°n",
            color=THEME_COLOR,
        )
        embed.add_field(
            name="üéöÔ∏è L·ªánh c·∫•u h√¨nh",
            value=_fmt_cmd_list([
                "`/profile <mode>` ‚Äî Thay ƒë·ªïi ch·∫•t l∆∞·ª£ng",
                "`/volume <s·ªë>` ‚Äî ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng",
                "`/debug_track <b√†i>` ‚Äî Ki·ªÉm tra metadata"
            ]),
            inline=False,
        )
    elif page == "report":
        embed = discord.Embed(
            title="üíå B√°o c√°o & G√≥p √Ω",
            description="Gi√∫p Monica ng√†y c√†ng ho√†n thi·ªán h∆°n",
            color=THEME_COLOR,
        )
        embed.add_field(
            name="üìù C√°ch b√°o c√°o",
            value=_fmt_cmd_list([
                "`/report` ‚Äî M·ªü form b√°o c√°o",
                "M√¥ t·∫£ chi ti·∫øt v·∫•n ƒë·ªÅ g·∫∑p ph·∫£i",
                "ƒê·ªôi ng≈© s·∫Ω xem x√©t v√† ph·∫£n h·ªìi"
            ]),
            inline=False,
        )
    elif page == "sources":
        embed = discord.Embed(
            title="‚ú® Ngu·ªìn nh·∫°c",
            description="Monica h·ªó tr·ª£ nhi·ªÅu n·ªÅn t·∫£ng √¢m nh·∫°c",
            color=THEME_COLOR,
        )
        embed.add_field(
            name="üé∂ N·ªÅn t·∫£ng ƒë∆∞·ª£c h·ªó tr·ª£",
            value=_fmt_cmd_list([
                "YouTube ‚Äî Video v√† nh·∫°c",
                "SoundCloud ‚Äî √Çm nh·∫°c ƒë·ªôc l·∫≠p", 
                "Bandcamp ‚Äî Ngh·ªá sƒ© indie"
            ]),
            inline=False,
        )
        embed.add_field(
            name="üëã M·∫πo t√¨m nh·∫°c",
            value="Th·ª≠ c·∫£ t√™n b√†i v√† t√™n ngh·ªá sƒ© ƒë·ªÉ c√≥ k·∫øt qu·∫£ t·ªët nh·∫•t",
            inline=False,
        )
    else:
        # overview
        embed = discord.Embed(
            title="üéµ Monica Bot ‚Äî Tr·ª£ gi√∫p",
            color=THEME_COLOR,
            description="Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Monica! B·∫Øt ƒë·∫ßu v·ªõi `/play <t√™n b√†i>` ƒë·ªÉ ph√°t nh·∫°c",
        )
        embed.add_field(
            name="üéØ C√°c nh√≥m l·ªánh",
            value=_fmt_cmd_list([
                "üéµ **Ph√°t nh·∫°c** ‚Äî ƒêi·ªÅu khi·ªÉn ph√°t nh·∫°c",
                "üìú **H√†ng ƒë·ª£i** ‚Äî Qu·∫£n l√Ω playlist",
                "üîÅ **Loop & L·ªãch s·ª≠** ‚Äî L·∫∑p l·∫°i b√†i h√°t",
                "‚ÑπÔ∏è **Th√¥ng tin** ‚Äî Theo d√µi ho·∫°t ƒë·ªông"
            ]),
            inline=False,
        )

    # Footer ƒë∆°n gi·∫£n v√† g·ªçn g√†ng
    embed.set_footer(text=f"Monica Music Bot {version} ‚Ä¢ S·ª≠ d·ª•ng dropdown ƒë·ªÉ kh√°m ph√° th√™m")
    return embed


class HelpSelect(ui.Select):
    """Select chuy·ªÉn trang tr·ª£ gi√∫p v·ªõi giao di·ªán th√¢n thi·ªán."""
    def __init__(self, *, default_page: str = "overview"):
        options = [
            discord.SelectOption(label="üè† T·ªïng quan", value="overview", emoji="üéµ", description="B·∫Øt ƒë·∫ßu v·ªõi Monica"),
            discord.SelectOption(label="üé∂ Ph√°t nh·∫°c", value="playback", emoji="üé∂", description="Ph√°t v√† ƒëi·ªÅu khi·ªÉn nh·∫°c"),
            discord.SelectOption(label="üìú H√†ng ƒë·ª£i", value="queue", emoji="üìú", description="Qu·∫£n l√Ω danh s√°ch ph√°t"),
            discord.SelectOption(label="üîÅ Loop", value="loop", emoji="üîÅ", description="L·∫∑p l·∫°i b√†i h√°t"),
            discord.SelectOption(label="‚ÑπÔ∏è Th√¥ng tin", value="info", emoji="‚ÑπÔ∏è", description="Tr·∫°ng th√°i bot"),
            discord.SelectOption(label="‚öôÔ∏è C·∫•u h√¨nh", value="config", emoji="‚öôÔ∏è", description="T√πy ch·ªânh Monica"),
            discord.SelectOption(label="üíå B√°o c√°o", value="report", emoji="üíå", description="G√≥p √Ω v√† b√°o l·ªói"),
            discord.SelectOption(label="üåç Ngu·ªìn nh·∫°c", value="sources", emoji="üåç", description="N·ªÅn t·∫£ng h·ªó tr·ª£"),
        ]
        super().__init__(
            placeholder="Ch·ªçn nh√≥m l·ªánh ƒë·ªÉ xem chi ti·∫øt",
            min_values=1,
            max_values=1,
            options=options,
            row=0,
        )
        self.current_page = default_page
        self._prefix = "!"
        self._version = ""
        self._profile = None

    def bind_meta(self, *, prefix: str, version: str, profile: str | None):
        self._prefix = prefix
        self._version = version
        self._profile = profile
        return self

    async def callback(self, interaction: discord.Interaction):  # type: ignore[override]
        try:
            metric_inc("ui_help_change_page")
        except Exception:
            pass
        self.current_page = self.values[0]
        embed = create_help_embed(
            self.current_page, prefix=self._prefix, version=self._version, stream_profile=self._profile
        )
        # Gia h·∫°n view khi chuy·ªÉn trang
        try:
            if self.view:
                self.view.timeout = max((self.view.timeout or 0), 120)
                self.view.restart()
        except Exception:
            pass
        await interaction.response.edit_message(embed=embed, view=self.view)


class HelpView(ui.View):
    """View ch·ª©a Select chuy·ªÉn trang v√† n√∫t m·ªü Report."""
    def __init__(self, *, prefix: str, version: str, stream_profile: str | None = None, timeout: float = 300):
        super().__init__(timeout=timeout)
        sel = HelpSelect().bind_meta(prefix=prefix, version=version, profile=stream_profile)
        self.add_item(sel)

    @ui.button(emoji="üíå", label="G·ª≠i g√≥p √Ω cho Monica", style=discord.ButtonStyle.secondary, row=1)
    async def open_report(self, interaction: discord.Interaction, button: ui.Button):
        """M·ªü form b√°o c√°o th√¢n thi·ªán."""
        try:
            metric_inc("ui_click_open_report")
        except Exception:
            pass
        try:
            modal = ReportModal(interaction.user, interaction.guild)
            await interaction.response.send_modal(modal)
        except Exception:
            await interaction.response.send_message(
                "üö´ Oops! Kh√¥ng th·ªÉ m·ªü form b√°o c√°o l√∫c n√†y. Th·ª≠ l·∫°i sau nh√©! üòÖ", 
                ephemeral=True
            )


# =============================
# Queue paginator (Prev/Next)
# =============================

class QueuePaginatorView(ui.View):
    """View ph√¢n trang danh s√°ch h√†ng ƒë·ª£i v·ªõi n√∫t Prev/Next.

    - M·ªói trang t·ªëi ƒëa 10 b√†i
    - Kh√¥ng thay ƒë·ªïi logic queue, ch·ªâ ƒë·ªçc snapshot t·∫°i th·ªùi ƒëi·ªÉm m·ªü
    - D√πng chung cho slash (ephemeral) v√† text (c√¥ng khai)
    """

    def __init__(self, items: list, *, title: str = "Queue (next up)", page_size: int = 10, timeout: float = 180.0):
        super().__init__(timeout=timeout)
        self._items = items or []
        self._page_size = max(1, page_size)
        self._title = title
        self._page = 0

    def _total_pages(self) -> int:
        import math
        return max(1, math.ceil(len(self._items) / self._page_size))

    def _page_slice(self):
        start = self._page * self._page_size
        end = start + self._page_size
        return self._items[start:end]

    def build_embed(self) -> discord.Embed:
        cur = self._page_slice()
        if not cur:
            desc = "Tr·ªëng"
        else:
            lines = []
            base_index = self._page * self._page_size
            for i, item in enumerate(cur):
                idx = base_index + i + 1
                if isinstance(item, dict):
                    title = truncate(item.get('title') or str(item), 50)
                    dur = format_duration(item.get('duration'))
                else:
                    title = truncate(str(item), 50)
                    dur = format_duration(None)
                lines.append(f"{idx}. {title} ‚Äî {dur}")
            desc = "\n".join(lines)
        embed = discord.Embed(title=self._title, description=desc, color=THEME_COLOR)
        embed.set_footer(text=f"Trang {self._page+1}/{self._total_pages()}")
        return embed

    async def refresh(self, interaction: discord.Interaction):
        # C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t v√† embed
        total = self._total_pages()
        prev_btn: ui.Button = self.children[0]  # type: ignore[assignment]
        next_btn: ui.Button = self.children[1]  # type: ignore[assignment]
        prev_btn.disabled = (self._page <= 0)
        next_btn.disabled = (self._page >= total - 1)
        # Gia h·∫°n khi c√≥ t∆∞∆°ng t√°c
        try:
            self.timeout = max((self.timeout or 0), 120)
            self.restart()
        except Exception:
            pass
        await interaction.response.edit_message(embed=self.build_embed(), view=self)

    @ui.button(emoji="‚¨ÖÔ∏è", label="Prev", style=discord.ButtonStyle.secondary)
    async def prev_page(self, interaction: discord.Interaction, button: ui.Button):
        try:
            metric_inc("ui_queue_prev")
        except Exception:
            pass
        if self._page > 0:
            self._page -= 1
        await self.refresh(interaction)

    @ui.button(emoji="‚û°Ô∏è", label="Next", style=discord.ButtonStyle.secondary)
    async def next_page(self, interaction: discord.Interaction, button: ui.Button):
        try:
            metric_inc("ui_queue_next")
        except Exception:
            pass
        total = self._total_pages()
        if self._page < total - 1:
            self._page += 1
        await self.refresh(interaction)


def create_now_playing_embed(data: dict, extra_desc: Optional[str] = None, *, stream_profile: Optional[str] = None) -> discord.Embed:
    """Create standardized now-playing embed."""
    title = truncate(data.get("title", "Now Playing"), 80)
    embed = discord.Embed(
        title=title,
        url=data.get("webpage_url"),
        color=THEME_COLOR,
        timestamp=discord.utils.utcnow(),
        description=(f"{'üî¥ LIVE' if data.get('is_live') else 'üéß Now Playing'}\n"
                     f"{extra_desc if extra_desc else ''}")
    )
    
    if data.get("thumbnail"):
        try:
            embed.set_thumbnail(url=data.get("thumbnail"))
        except Exception:
            pass
    
    embed.add_field(
        name="üë§ Ngh·ªá sƒ©", 
        value=truncate(data.get("uploader") or "Unknown", 64), 
        inline=True
    )
    embed.add_field(
        name="‚è±Ô∏è Th·ªùi l∆∞·ª£ng", 
        value=format_duration(data.get("duration")), 
        inline=True
    )
    
    if data.get("requested_by"):
        embed.add_field(
            name="üôã Y√™u c·∫ßu", 
            value=truncate(data.get("requested_by"), 30), 
            inline=True
        )
    
    try:
        if not stream_profile:
            # Best-effort: l·∫•y t·ª´ config n·∫øu kh√¥ng truy·ªÅn v√†o
            try:
                from modules.config import load_config as _load_cfg
                stream_profile = _load_cfg().get("stream_profile")
            except Exception:
                stream_profile = None
        footer_txt = (
            f"Profile: {stream_profile} ‚Ä¢ S·∫Ω m·∫•t th√™m v√†i gi√¢y ƒë·ªÉ m√¨nh x·ª≠ l√Ω y√™u c·∫ßu. B·∫°n ch·ªãu kh√≥ ƒë·ª£i th√™m ch√∫t nha üíï"
            if stream_profile else
            "S·∫Ω m·∫•t th√™m v√†i gi√¢y ƒë·ªÉ m√¨nh x·ª≠ l√Ω y√™u c·∫ßu. B·∫°n ch·ªãu kh√≥ ƒë·ª£i th√™m ch√∫t nha üíï"
        )
        embed.set_footer(text=footer_txt)
    except Exception:
        pass
    
    return embed


def create_queue_add_embed(track_data: dict) -> discord.Embed:
    """Create standardized queue-add embed."""
    desc_title = truncate(track_data.get("title", "ƒê√£ th√™m v√†o h√†ng ƒë·ª£i"), 80)
    embed = discord.Embed(
        title="‚úÖ ƒê√£ th√™m v√†o h√†ng ƒë·ª£i",
        url=track_data.get("webpage_url"),
        description=desc_title,
        color=discord.Color.green(),
    )
    
    if track_data.get("thumbnail"):
        try:
            embed.set_thumbnail(url=track_data.get("thumbnail"))
        except Exception:
            pass
    
    if track_data.get("uploader"):
        embed.add_field(
            name="üë§ Ngh·ªá sƒ©", 
            value=truncate(track_data.get("uploader"), 64), 
            inline=True
        )
    
    if track_data.get("duration"):
        embed.add_field(
            name="‚è±Ô∏è Th·ªùi l∆∞·ª£ng", 
            value=format_duration(track_data.get("duration")), 
            inline=True
        )
    
    embed.set_footer(text="N·∫øu g·∫∑p b·∫°n g·∫∑p ph·∫£i l·ªói g√¨ th√¨ d√πng /report ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ s·ª≠a l·ªói nhanh ch√≥ng nh√© ‚ú®")
    return embed


def create_error_embed(message: str, title: str = "‚ùå L·ªói") -> discord.Embed:
    """Create standardized error embed."""
    return discord.Embed(
        title=title,
        description=message,
        color=ERR_COLOR
    )
